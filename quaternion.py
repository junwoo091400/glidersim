"""A scratchpad for quaternion work."""
from numpy import rad2deg, deg2rad, sin, cos
import numpy as np

from IPython import embed


def skew(v):
    # Implements the skew operator for a vector
    assert v.shape in ((3,), (3, 1))
    vx, vy, vz = v.flatten()
    sv = [[0, -vz, vy],
          [vz, 0, -vx],
          [-vy, vx, 0]]
    return np.asarray(sv)


def euler_to_dcm(euler):
    """
    Convert a set of Euler angles to a DCM

    Parameters
    ----------
    euler : array of float, shape (3,)
        The [phi, theta, gamma] in radians, specifying the rotation as a
        yaw-pitch-roll sequence.

    Returns
    -------
    dcm : ndarray of float, shape (3,3)
        The direction cosine matrix that would apply the given rotation
    """
    sp, st, sg = np.sin(euler)
    cp, ct, cg = np.cos(euler)
    dcm = [[ct*cg,                         ct*sg,   -st],
           [-cp*sg + sp*st*cg,  cp*cg + sp*st*sg, sp*ct],
           [sp*sg + cp*st*cg,  -sp*cg + cp*st*sg, cp*ct]]

    return np.asarray(dcm)


def dcm_to_euler(dcm):
    """
    Convert a direction cosine matrix to the yaw-pitch-roll Euler angles
    """
    phi = np.arctan2(dcm[1, 2], dcm[2, 2])
    theta = -np.arcsin(dcm[0, 2])
    gamma = np.arctan2(dcm[0, 1], dcm[0, 0])
    return np.array([phi, theta, gamma])


def euler_to_quaternion(euler):
    """
    Convert a set of Euler angles to a quaternion

    Parameters
    ----------
    euler : array of float, shape (3,)
        The [phi, theta, gamma] in radians, specifying the rotation as a
        yaw-pitch-roll sequence.

    Returns
    -------
    q : array of float, shape (4,)
        The quaternion that encodes the given rotation
    """
    euler = np.asarray(euler)
    sp, st, sg = np.sin(euler/2)
    cp, ct, cg = np.cos(euler/2)

    # ref: Stevens, Equation on pg 52 (66)
    q = np.asarray([cp*ct*cg + sp*st*sg,
                    sp*ct*cg - cp*st*sg,
                    cp*st*cg + sp*ct*sg,
                    cp*ct*sg - sp*st*cg])
    return q


def quaternion_to_dcm(q):
    assert q.shape in ((4,), (4, 1))
    q = q.reshape(4, 1)
    qw, qv = q[0], q[1:]

    # ref: Stevens, Eq:1.8-18, pg 53 (67)
    dcm = 2*qv@qv.T + (qw**2 - qv.T@qv)*np.eye(3) - 2*qw*skew(qv)

    return np.asarray(dcm)


def apply_quaternion_rotation(q, u):
    # Encodes `v = q^-1 * u * q`, where `*` is the quaternion product,
    # and `u` has been converted to a quaternion, `u = [0, u]`
    #
    # ref: Stevens, Eg:1.8-8, pg 49 (63)
    assert u.shape in ((3,), (3, 1))
    u = u.ravel()
    qw, qv = q[0], q[1:]
    v = np.r_[0, 2*qv*(qv@u) + (qw**2 - qv@qv)*u - 2*qw*np.cross(qv, u)]
    return v


def main():

    # The quaternion and euler should produce the same rotation
    while True:
        phi = np.random.uniform(-np.pi, np.pi)
        theta = np.random.uniform(-np.pi/2, np.pi)
        gamma = np.random.uniform(-np.pi, np.pi)
        euler = [phi, theta, gamma]
        q = euler_to_quaternion(euler)

        # Cross-check the two DCM generation methods
        dcm_e = euler_to_dcm(euler)
        dcm_q = quaternion_to_dcm(q)
        if not np.allclose(dcm_e, dcm_q):
            print("\nThe DCM generated by the quaternion doesn't match\n")
            embed()

        # Transform a random vector using both methods
        u = np.random.random(3)  # A random 3-vector
        ve = dcm_e @ u
        vq = apply_quaternion_rotation(q, u)

        print("\n")
        print(f"euler: {np.rad2deg(euler)}")
        print(f"u:     {u}")
        print("------------------------------------------")
        print(f"ve:    {ve}")
        print(f"vq:    {vq[1:]}")

        if not np.isclose(vq[0], 0):
            print("\nNon-zero scalar part in the quaternion representation")
            embed()

        if not np.allclose(ve, vq[1:]):
            print("\nWrong!")
            embed()


if __name__ == "__main__":
    main()
